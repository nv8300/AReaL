import asyncio
from concurrent.futures import ProcessPoolExecutor
from functools import lru_cache, partial
from typing import Callable, List, Optional

from realhf.base import logging

logger = logging.getLogger("Reward API")


def reward_fn(
    prompt: str,
    completions: str,
    prompt_ids: List[int],
    completion_ids: List[int],
    **kwargs,
):
    """This function is a placeholder for the reward function that will be used in the RLVR pipeline.

    In general, there's no restriction on the signature and implementation of this function in customized rollout workflows.
    It would be convinent to follow this signature and directly use it in our predefined rollout workflows.

    :param prompt: The string representing the task to be completed.
    :param completions: The string representing the trajectory generated by the model.
    :param prompt_ids: The token IDs of the prompt.
    :param completion_ids: The token IDs of the trajectory generated by the model.
    :param kwargs: Other attributes of the data in the dataset, such as solutions, input_outputs, etc.
        Any other attributes in the dataset will be passed as keyword arguments to this function.
    :rtype: float
    """


@lru_cache(maxsize=1)
def get_rw_executor(max_workers):
    return ProcessPoolExecutor(max_workers=max_workers)


class AsyncRewardWrapper:
    """
    Wraps a synchronous reward function to make it async with timeout handling.
    """

    def __init__(
        self,
        reward_fn: Callable,
        timeout_seconds: float = 15,
        max_workers: Optional[int] = None,
    ):
        self.reward_fn = reward_fn
        self.timeout_seconds = timeout_seconds
        self.max_workers = max_workers

    async def __call__(self, *args, **kwargs) -> float:
        rw_executor = get_rw_executor(self.max_workers)
        loop = asyncio.get_event_loop()
        try:
            return await asyncio.wait_for(
                loop.run_in_executor(
                    rw_executor,
                    partial(self.reward_fn, *args, **kwargs),
                ),
                timeout=self.timeout_seconds,
            )
        except asyncio.TimeoutError:
            logger.warning(
                f"Computing reward timeout after {self.timeout_seconds}s. Set reward to 0."
            )
            return 0
